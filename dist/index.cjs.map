{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import * as crypto from \"crypto\";\n\nexport default class ValidateTelegramWebAppData {\n    /**\n     * Creates ValidateTelegramWebAppData instance.\n     * @constructor\n     * @param {string} telegramBotToken - your Telegram bot's token\n     */\n    telegramBotToken: string;\n\n    constructor(telegramBotToken: string) {\n        this.telegramBotToken = telegramBotToken;\n    }\n\n    /**\n     * @param {string} initData - initData received from Telegram\n     * @param {number} secondsToExpire - number of seconds to expire from auth_date; enter 0 to ignore expiry check\n     * @returns {ValidateDataResponse} - Returns an object with keys 'isValid' and 'data'. \n     * - Value of 'isValid' will be true if data is valid; false if data is invalid/has expired. \n     * - Value of 'data' contains the parsed initData in object\n     */\n    ValidateData(initData: any, secondsToExpire: number): ValidateDataResponse {\n        const params = new URLSearchParams(initData);\n        const data: WebAppInitData = {};\n        let hash = \"\";\n        for (const [key, value] of params.entries()) {\n            key === \"hash\" ? hash = value : data[key] = value;\n        };\n        const dataCheckString = Object.keys(data)\n            .sort()\n            .map(key => `${key}=${data[key]}`)\n            .join('\\n');\n        const secret_key = crypto.createHmac('sha256', 'WebAppData').update(this.telegramBotToken).digest();\n        const hmac = crypto.createHmac('sha256', secret_key).update(dataCheckString).digest('hex');\n        const currentTime = Date.now() / 1000;\n        const currentAndAuthTimeDiff = currentTime - data['auth_date'];\n        if (secondsToExpire == 0) {\n            return {\n                isValid: hmac === hash ? true : false,\n                data\n            }\n        } else {\n            return {\n                isValid: currentAndAuthTimeDiff < secondsToExpire && hmac === hash ? true : false,\n                data\n            }\n        }\n    }\n}\n\ninterface ValidateDataResponse {\n    isValid: boolean,\n    data: WebAppInitData\n}\n\ninterface WebAppUser {\n    id: number,\n    is_bot?: boolean,\n    first_name: string,\n    last_name?: string,\n    username?: string,\n    language_code?: string,\n    is_premium?: true,\n    added_to_attachment_menu?: true,\n    allows_write_to_pm?: true,\n    photo_url?: string\n};\n\ninterface WebAppChat {\n    id: number,\n    type: string,\n    title: string,\n    username?: string,\n    photo_url?: string\n};\n\ninterface WebAppInitData {\n    query_id?: string,\n    user?: WebAppUser,\n    receiver?: WebAppUser,\n    chat?: WebAppChat,\n    chat_type?: string,\n    chat_instance?: string,\n    start_param?: string,\n    can_send_after?: number,\n    auth_date?: number | undefined,\n    hash?: string | undefined\n};"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAAwB;AAExB,IAAqB,6BAArB,MAAgD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAM5C;AAAA,EAEA,YAAY,kBAA0B;AAClC,SAAK,mBAAmB;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,aAAa,UAAe,iBAA+C;AACvE,UAAM,SAAS,IAAI,gBAAgB,QAAQ;AAC3C,UAAM,OAAuB,CAAC;AAC9B,QAAI,OAAO;AACX,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,GAAG;AACzC,cAAQ,SAAS,OAAO,QAAQ,KAAK,GAAG,IAAI;AAAA,IAChD;AAAC;AACD,UAAM,kBAAkB,OAAO,KAAK,IAAI,EACnC,KAAK,EACL,IAAI,SAAO,GAAG,GAAG,IAAI,KAAK,GAAG,CAAC,EAAE,EAChC,KAAK,IAAI;AACd,UAAM,aAAoB,kBAAW,UAAU,YAAY,EAAE,OAAO,KAAK,gBAAgB,EAAE,OAAO;AAClG,UAAM,OAAc,kBAAW,UAAU,UAAU,EAAE,OAAO,eAAe,EAAE,OAAO,KAAK;AACzF,UAAM,cAAc,KAAK,IAAI,IAAI;AACjC,UAAM,yBAAyB,cAAc,KAAK,WAAW;AAC7D,QAAI,mBAAmB,GAAG;AACtB,aAAO;AAAA,QACH,SAAS,SAAS,OAAO,OAAO;AAAA,QAChC;AAAA,MACJ;AAAA,IACJ,OAAO;AACH,aAAO;AAAA,QACH,SAAS,yBAAyB,mBAAmB,SAAS,OAAO,OAAO;AAAA,QAC5E;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;","names":[]}